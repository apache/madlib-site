<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="keywords" content="madlib,postgres,greenplum,machine learning,data mining,deep learning,ensemble methods,data science,market basket analysis,affinity analysis,pca,lda,regression,elastic net,huber white,proportional hazards,k-means,latent dirichlet allocation,bayes,support vector machines,svm"/>
<title>MADlib: Ordinal Regression</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<!-- hack in the navigation tree -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="madlib_extra.css" rel="stylesheet" type="text/css"/>
<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45382226-1', 'madlib.apache.org');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://madlib.apache.org"><img alt="Logo" src="madlib.png" height="50" style="padding-left:0.5em;" border="0"/ ></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   <span id="projectnumber">1.20.0</span>
   </div>
   <div id="projectbrief">User Documentation for Apache MADlib</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__grp__ordinal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Ordinal Regression<div class="ingroups"><a class="el" href="group__grp__super.html">Supervised Learning</a> &raquo; <a class="el" href="group__grp__regml.html">Regression Models</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><b>Contents</b> <ul>
<li class="level1">
<a href="#train">Training Function</a> </li>
<li class="level1">
<a href="#predict">Prediction Function</a> </li>
<li class="level1">
<a href="#examples">Examples</a> </li>
<li class="level1">
<a href="#background">Model Details</a> </li>
<li class="level1">
<a href="#literature">Literature</a> </li>
<li class="level1">
<a href="#related">Related Topics</a> </li>
</ul>
</div><p>In statistics, ordinal regression is a type of regression analysis used for predicting an ordinal variable, i.e. a variable whose value exists on an arbitrary scale where only the relative ordering between different values is significant. The two most common types of ordinal regression models are ordered logit, which applies to data that meet the proportional odds assumption, and ordered probit.</p>
<p><a class="anchor" id="train"></a></p><dl class="section user"><dt>Training Function</dt><dd>The ordinal regression training function has the following syntax: <pre class="syntax">
ordinal(source_table,
         model_table,
         dependent_varname,
         independent_varname,
         cat_order,
         link_func,
         grouping_col,
         optim_params,
         verbose
        )
</pre></dd></dl>
<p><b>Arguments</b> </p><dl class="arglist">
<dt>source_table </dt>
<dd><p class="startdd">VARCHAR. Name of the table containing the training data.</p>
<p class="enddd"></p>
</dd>
<dt>model_table </dt>
<dd><p class="startdd">VARCHAR. Name of the generated table containing the model.</p>
<p>The model table produced by ordinal() contains the following columns:</p>
<table class="output">
<tr>
<th>&lt;...&gt; </th><td><p class="starttd">Grouping columns, if provided in input. This could be multiple columns depending on the <code>grouping_col</code> input. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>coef_threshold </th><td><p class="starttd">FLOAT8[]. Vector of the threshold coefficients in linear predictor. The threshold coefficients are the intercepts specific to each categorical levels </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>std_err_threshold </th><td><p class="starttd">FLOAT8[]. Vector of the threshold standard errors of the threshold coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>z_stats_threshold </th><td><p class="starttd">FLOAT8[]. Vector of the threshold z-statistics of the thresholdcoefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>p_values_threshold </th><td><p class="starttd">FLOAT8[]. Vector of the threshold p-values of the threshold coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>log_likelihood </th><td><p class="starttd">FLOAT8. The log-likelihood \( l(\boldsymbol \beta) \). The value will be the same across categories within the same group. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>coef_feature </th><td><p class="starttd">FLOAT8[]. Vector of the feature coefficients in linear predictor. The feature coefficients are the coefficients for the independent variables. They are the same across categories. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>std_err_feature </th><td><p class="starttd">FLOAT8[]. Vector of the feature standard errors of the feature coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>z_stats_feature </th><td><p class="starttd">FLOAT8[]. Vector of the feature z-statistics of the feature coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>p_values_feature </th><td><p class="starttd">FLOAT8[]. Vector of the feature p-values of the feature coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_rows_processed </th><td><p class="starttd">BIGINT. Number of rows processed. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_rows_skipped </th><td><p class="starttd">BIGINT. Number of rows skipped due to missing values or failures. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_iterations </th><td>INTEGER. Number of iterations actually completed. This would be different from the <code>nIterations</code> argument if a <code>tolerance</code> parameter is provided and the algorithm converges before all iterations are completed.  </td></tr>
</table>
<p>A summary table named &lt;model_table&gt;_summary is also created at the same time, which has the following columns: </p><table class="output">
<tr>
<th>method </th><td><p class="starttd">VARCHAR. String describes the model: 'ordinal'. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>source_table </th><td><p class="starttd">VARCHAR. Data source table name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>model_table </th><td><p class="starttd">VARCHAR. Model table name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>dependent_varname </th><td><p class="starttd">VARCHAR. Expression for dependent variable. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>independent_varname </th><td><p class="starttd">VARCHAR. Expression for independent variables. The independent variables should not include intercept term. Otherwise there will be an error message indicating Hessian matrix is not finite. In that case, the user should drop the intercept and rerun the function agian. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>cat_order </th><td><p class="starttd">VARCHAR. String representation of category order. Default is the sorted categories in data using python sort </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>link_func </th><td><p class="starttd">VARCHAR. String that contains link function parameters: 'logit' and 'probit' links are implemented now </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>grouping_col </th><td><p class="starttd">VARCHAR. String representation of grouping columns. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>optimizer_params </th><td><p class="starttd">VARCHAR. String that contains optimizer parameters, and has the form of 'optimizer=..., max_iter=..., tolerance=...'. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_all_groups </th><td><p class="starttd">INTEGER. Number of groups in ordinal regression training. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_failed_groups </th><td><p class="starttd">INTEGER. Number of failed groups in ordinal regression training. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>total_rows_processed </th><td><p class="starttd">BIGINT. Total number of rows processed in all groups. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>total_rows_skipped </th><td><p class="starttd">BIGINT. Total number of rows skipped in all groups due to missing values or failures. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p class="enddd"></p>
</dd>
<dt>dependent_varname </dt>
<dd><p class="startdd">VARCHAR. Name of the dependent variable column.</p>
<p class="enddd"></p>
</dd>
<dt>independent_varname </dt>
<dd><p class="startdd">VARCHAR. Expression list to evaluate for the independent variables. The intercept should not be included here since the cumulative probability force to have intercepts for each category level.</p>
<p class="enddd"></p>
</dd>
<dt>cat_order </dt>
<dd><p class="startdd">VARCHAR, String that represents the order of category. The order is specified by charactor '&lt;'. </p>
<p class="enddd"></p>
</dd>
<dt>link_function (optional) </dt>
<dd><p class="startdd">VARCHAR, default: 'logit'. Parameters for link function. Currently, we support logit and probit. </p>
<p class="enddd"></p>
</dd>
<dt>grouping_col (optional) </dt>
<dd><p class="startdd">VARCHAR, default: NULL. An expression list used to group the input dataset into discrete groups, running one regression per group. Similar to the SQL "GROUP BY" clause. When this value is NULL, no grouping is used and a single model is generated.</p>
<p class="enddd"></p>
</dd>
<dt>optim_params (optional) </dt>
<dd><p class="startdd">VARCHAR, default: 'max_iter=100,optimizer=irls,tolerance=1e-6'. Parameters for optimizer. Currently, we support tolerance=[tolerance for relative error between log-likelihoods], max_iter=[maximum iterations to run], optimizer=irls.</p>
<p class="enddd"></p>
</dd>
<dt>verbose (optional) </dt>
<dd>BOOLEAN, default: FALSE. Provides verbose output of the results of training. </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To calculate the standard error the coefficient, we are using the square root of the diagnal elements of the expected Fisher information matrix, which is a by-product of iteratively reweighted least square. This method is used in the original ordinal regression paper by McCullagh(1980). In some software like Stata, the standard error is calculated by the observed information matrix, which is supported by Efron and Hinkley (1978). In R, polr() uses the approximated observed information matrix while the optimization is achieved by first order optimization method. Therefore, there will be some difference on standard error, z-stats and p-value from other software.</dd></dl>
<p><a class="anchor" id="predict"></a></p><dl class="section user"><dt>Prediction Function</dt><dd>Ordinal regression prediction function has the following format: <pre class="syntax">
ordinal_predict(
                    model_table,
                    predict_table_input,
                    output_table,
                    predict_type,
                    verbose
               )
</pre> <b>Arguments</b> <dl class="arglist">
<dt>model_table </dt>
<dd><p class="startdd">TEXT. Name of the generated table containing the model, which is the output table from ordinal().</p>
<p class="enddd"></p>
</dd>
<dt>predict_table_input </dt>
<dd><p class="startdd">TEXT. The name of the table containing the data to predict on. The table must contain id column as the primary key.</p>
<p class="enddd"></p>
</dd>
<dt>output_table </dt>
<dd><p class="startdd">TEXT. Name of the generated table containing the predicted values.</p>
<p>The model table produced by ordinal_predict contains the following columns:</p>
<table class="output">
<tr>
<th>id </th><td><p class="starttd">SERIAL. Column to identify the predicted value. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>category </th><td><p class="starttd">TEXT. Available if the predicted type = 'response'. Column contains the predicted categories </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>category_value </th><td>FLOAT8. The predicted probability for the specific category_value.  </td></tr>
</table>
<p class="enddd"></p>
</dd>
<dt>predict_type </dt>
<dd><p class="startdd">TEXT. Either 'response' or 'probability'. Using 'response' will give the predicted category with the largest probability. Using probability will give the predicted probabilities for all categories</p>
<p class="enddd"></p>
</dd>
<dt>verbose </dt>
<dd>BOOLEAN. Whether verbose is displayed </dd>
</dl>
</dd></dl>
<p><a class="anchor" id="examples"></a></p><dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ol type="1">
<li>Create the training data table. <pre class="example">
DROP TABLE IF EXISTS test3;
CREATE TABLE test3 (
    feat1 INTEGER,
    feat2 INTEGER,
    cat INTEGER
);
INSERT INTO test3(feat1, feat2, cat) VALUES
(1,35,1),
(2,33,0),
(3,39,1),
(1,37,1),
(2,31,1),
(3,36,0),
(2,36,1),
(2,31,1),
(2,41,1),
(2,37,1),
(1,44,1),
(3,33,2),
(1,31,1),
(2,44,1),
(1,35,1),
(1,44,0),
(1,46,0),
(2,46,1),
(2,46,2),
(3,49,1),
(2,39,0),
(2,44,1),
(1,47,1),
(1,44,1),
(1,37,2),
(3,38,2),
(1,49,0),
(2,44,0),
(3,61,2),
(1,65,2),
(3,67,1),
(3,65,2),
(1,65,2),
(2,67,2),
(1,65,2),
(1,62,2),
(3,52,2),
(3,63,2),
(2,59,2),
(3,65,2),
(2,59,0),
(3,67,2),
(3,67,2),
(3,60,2),
(3,67,2),
(3,62,2),
(2,54,2),
(3,65,2),
(3,62,2),
(2,59,2),
(3,60,2),
(3,63,2),
(3,65,2),
(2,63,1),
(2,67,2),
(2,65,2),
(2,62,2);
</pre></li>
<li>Run the multilogistic regression function. <pre class="example">
DROP TABLE IF EXISTS test3_output;
DROP TABLE IF EXISTS test3_output_summary;
SELECT madlib.ordinal('test3',
                       'test3_output',
                       'cat',
                       'ARRAY[feat1, feat2]',
                       '0&lt;1&lt;2',
                       'logit'
                       );
</pre></li>
<li>View the regression results. <pre class="example">
-- Set extended display on for easier reading of output
\x on
SELECT * FROM test3_output;
</pre> Result: <pre class="result">
-[ RECORD 1 ]------+-------------------------------------------
coef_threshold     | {4.12831944358935,6.55999442887089}
std_err_threshold  | {1.3603408170882,1.54843501580999}
z_stats_threshold  | {3.03476848722806,4.23653195768075}
p_values_threshold | {0.00240720390579325,2.26998625331282e-05}
log_likelihood     | -42.1390192418541
coef_feature       | {0.574822563129293,0.108115645059558}
std_err_feature    | {0.394064908788145,0.0276025960683975}
z_stats_feature    | {1.45870020473791,3.91686509456046}
p_values_feature   | {0.144647639733733,8.9707915817562e-05}
num_rows_processed | 57
num_rows_skipped   | 0
iteration          | 7
</pre></li>
<li>Predicting dependent variable using ordinal model. (This example uses the original data table to perform the prediction. Typically a different test dataset with the same features as the original training dataset would be used for prediction.) <pre class="example">
\x off
-- Add the id column for prediction function
ALTER TABLE test3 ADD COLUMN id SERIAL;
-- Predict probabilities for all categories using the original data
SELECT ordinal_predict('test3_output','test3', 'test3_prd_prob', 'probability');
-- Display the predicted value
SELECT * FROM test3_prd_prob;
</pre></li>
</ol>
<p><a class="anchor" id="background"></a></p><dl class="section user"><dt>Model Details</dt><dd></dd></dl>
<p>The function ordinal() fit the ordinal response model using a cumulative link model. The ordinal reponse variable, denoted by \( Y_i \), can fall in \( j = 1,.. , J\) categories. Then \( Y_i \) follows a multinomial distribution with parameter \(\pi\) where \(\pi_{ij}\) denote the probability that the \(i\)th observation falls in response category \(j\). We define the cumulative probabilities as </p><p class="formulaDsp">
\[ \gamma_{ij} = \Pr(Y_i \le j)= \pi_{i1} +...+ \pi_{ij} . \]
</p>
<p> Next we will consider the logit link for illustration purpose. The logit function is defined as \( \mbox{logit}(\pi) = \log[\pi/(1-\pi)] \) and cumulative logits are defined as: </p><p class="formulaDsp">
\[ \mbox{logit}(\gamma_{ij})=\mbox{logit}(\Pr(Y_i \le j))=\log \frac{\Pr(Y_i \le j)}{1-\Pr(Y_i\le j)}, j=1,...,J−1 \]
</p>
<p> so that the cumulative logits are defined for all but the last category.</p>
<p>A cumulative link model with a logit link, or simply cumulative logit model is a regression model for cumulative logits: </p><p class="formulaDsp">
\[ \mbox{logit}(\gamma_{ij}) = \theta_j - x^T_i \beta \]
</p>
<p> where \(x_i\) is a vector of explanatory variables for the \(i\)th observation and \(\beta\) is the corresponding set of regression parameters. The \(\{\theta_j\}\) parameters provide each cumulative logit (for each \(j\)) with its own intercept. A key point is that the regression part \(x^T_i\beta\) is independent of \(j\), so \(\beta\) has the same effect for each of the J − 1 cumulative logits. Note that \(x^T_i\beta\) does not contain an intercept, since the \(\{\theta_j\}\) act as intercepts. For small values of \(x^T_i\beta\) the response is likely to fall in the first category and for large values of \(x^T_i\beta\) the response is likely to fall in the last category. The horizontal displacements of the curves are given by the values of \(\{\theta_j\}\).</p>
<p><a class="anchor" id="literature"></a></p><dl class="section user"><dt>Literature</dt><dd></dd></dl>
<p>A collection of nice write-ups, with valuable pointers into further literature:</p>
<p>[1] Peter McCullagh: Regression Models for Ordinal Data, Journal of the Royal Statistical Society. Series B (Methodological), Volume 42, Issue 2 (1980), 109-142</p>
<p>[2] Rune Haubo B Christensen: Analysis of ordinal data with cumulative link models &ndash; estimation with the R-package ordinal. cran.r-project.org/web/packages/ordinal/vignettes/clm_intro.pdf</p>
<p><a class="anchor" id="related"></a></p><dl class="section user"><dt>Related Topics</dt><dd></dd></dl>
<p>File <a class="el" href="ordinal_8sql__in.html" title="SQL functions for ordinal regression. ">ordinal.sql_in</a> documenting the ordinal regression functions</p>
<p><a class="el" href="group__grp__multinom.html">Multinomial Regression</a></p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 19 2022 12:19:28 for MADlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
