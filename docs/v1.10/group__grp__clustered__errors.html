<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="keywords" content="madlib,postgres,greenplum,machine learning,data mining,deep learning,ensemble methods,data science,market basket analysis,affinity analysis,pca,lda,regression,elastic net,huber white,proportional hazards,k-means,latent dirichlet allocation,bayes,support vector machines,svm"/>
<title>MADlib: Clustered Variance</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<!-- hack in the navigation tree -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="madlib_extra.css" rel="stylesheet" type="text/css"/>
<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45382226-1', 'madlib.incubator.apache.org');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://madlib.incubator.apache.org"><img alt="Logo" src="madlib.png" height="50" style="padding-left:0.5em;" border="0"/ ></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   <span id="projectnumber">1.10.0</span>
   </div>
   <div id="projectbrief">User Documentation for MADlib</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__grp__clustered__errors.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Clustered Variance<div class="ingroups"><a class="el" href="group__grp__super.html">Supervised Learning</a> &raquo; <a class="el" href="group__grp__regml.html">Regression Models</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><b>Contents</b> <ul>
<li>
<a href="#train_linregr">Clustered Variance Linear Regression Training Function</a> </li>
<li>
<a href="#train_logregr">Clustered Variance Logistic Regression Training Function</a> </li>
<li>
<a href="#train_mlogregr">Clustered Variance Multinomial Logistic Regression Training Function</a> </li>
<li>
<a href="#train_cox">Clustered Variance for Cox Proportional Hazards model</a> </li>
<li>
<a href="#examples">Examples</a> </li>
<li>
<a href="#notes">Notes</a> </li>
<li>
<a href="#background">Technical Background</a> </li>
<li>
<a href="#related">Related Topics</a> </li>
</ul>
</div><p>The Clustered Variance module adjusts standard errors for clustering. For example, replicating a dataset 100 times should not increase the precision of parameter estimates, but performing this procedure with the IID assumption will actually do this. Another example is in economics of education research, it is reasonable to expect that the error terms for children in the same class are not independent. Clustering standard errors can correct for this.</p>
<p>The MADlib Clustered Variance module includes functions to calculate linear, logistic, and multinomial logistic regression problems.</p>
<p><a class="anchor" id="train_linregr"></a></p><dl class="section user"><dt>Clustered Variance Linear Regression Training Function</dt><dd></dd></dl>
<p>The clustered variance linear regression training function has the following syntax. </p><pre class="syntax">
clustered_variance_linregr ( source_table,
                             out_table,
                             dependent_varname,
                             independent_varname,
                             clustervar,
                             grouping_cols
                           )
</pre><p> <b>Arguments</b> </p><dl class="arglist">
<dt>source_table </dt>
<dd><p class="startdd">TEXT. The name of the table containing the input data.</p>
<p class="enddd"></p>
</dd>
<dt>out_table </dt>
<dd><p class="startdd">VARCHAR. Name of the generated table containing the output model. The output table contains the following columns. </p><table class="output">
<tr>
<th>coef </th><td>DOUBLE PRECISION[]. Vector of the coefficients of the regression.  </td></tr>
<tr>
<th>std_err </th><td>DOUBLE PRECISION[]. Vector of the standard error of the coefficients.  </td></tr>
<tr>
<th>t_stats </th><td>DOUBLE PRECISION[]. Vector of the t-stats of the coefficients.  </td></tr>
<tr>
<th>p_values </th><td>DOUBLE PRECISION[]. Vector of the p-values of the coefficients.  </td></tr>
</table>
<p>A summary table named &lt;out_table&gt;_summary is also created, which is the same as the summary table created by linregr_train function. Please refer to the documentation for linear regression for details.</p>
<p></p>
<p class="enddd"></p>
</dd>
<dt>dependent_varname </dt>
<dd>TEXT. An expression to evaluate for the dependent variable. </dd>
<dt>independent_varname </dt>
<dd>TEXT. An Expression to evalue for the independent variables. </dd>
<dt>clustervar </dt>
<dd>TEXT. A comma-separated list of the columns to use as cluster variables. </dd>
<dt>grouping_cols (optional) </dt>
<dd>TEXT, default: NULL. <em>Not currently implemented. Any non-NULL value is ignored.</em> An expression list used to group the input dataset into discrete groups, running one regression per group. Similar to the SQL GROUP BY clause. When this value is null, no grouping is used and a single result model is generated. </dd>
</dl>
<p><a class="anchor" id="train_logregr"></a></p><dl class="section user"><dt>Clustered Variance Logistic Regression Training Function</dt><dd></dd></dl>
<p>The clustered variance logistic regression training function has the following syntax. </p><pre class="syntax">
clustered_variance_logregr( source_table,
                            out_table,
                            dependent_varname,
                            independent_varname,
                            clustervar,
                            grouping_cols,
                            max_iter,
                            optimizer,
                            tolerance,
                            verbose_mode
                          )
</pre><p> <b>Arguments</b> </p><dl class="arglist">
<dt>source_table </dt>
<dd>TEXT. The name of the table containing the input data. </dd>
<dt>out_table </dt>
<dd><p class="startdd">VARCHAR. Name of the generated table containing the output model. The output table has the following columns: </p><table class="output">
<tr>
<th>coef </th><td>Vector of the coefficients of the regression.  </td></tr>
<tr>
<th>std_err </th><td>Vector of the standard error of the coefficients.  </td></tr>
<tr>
<th>z_stats </th><td>Vector of the z-stats of the coefficients.  </td></tr>
<tr>
<th>p_values </th><td>Vector of the p-values of the coefficients.  </td></tr>
</table>
<p>A summary table named &lt;out_table&gt;_summary is also created, which is the same as the summary table created by logregr_train function. Please refer to the documentation for logistic regression for details.</p>
<p class="enddd"></p>
</dd>
<dt>dependent_varname </dt>
<dd>TEXT. An expression to evaluate for the dependent variable. </dd>
<dt>independent_varname </dt>
<dd>TEXT. An expression to evaluate for the independent variable. </dd>
<dt>clustervar </dt>
<dd>TEXT. A comma-separated list of columns to use as cluster variables. </dd>
<dt>grouping_cols (optional) </dt>
<dd>TEXT, default: NULL. <em>Not yet implemented. Any non-NULL values are ignored.</em> An expression list used to group the input dataset into discrete groups, running one regression per group. Similar to the SQL GROUP BY clause. When this value is NULL, no grouping is used and a single result model is generated. </dd>
<dt>max_iter (optional) </dt>
<dd>INTEGER, default: 20. The maximum number of iterations that are allowed. </dd>
<dt>optimizer (optional) </dt>
<dd>TEXT, default: 'irls'. The name of the optimizer to use: <ul>
<li>
'newton' or 'irls': Iteratively reweighted least squares </li>
<li>
'cg': conjugate gradient </li>
<li>
'igd': incremental gradient descent. </li>
</ul>
</dd>
<dt>tolerance (optional) </dt>
<dd>FLOAT8, default: 0.0001 The difference between log-likelihood values in successive iterations that should indicate convergence. A zero disables the convergence criterion, so that execution stops after <em>n</em> Iterations have completed. </dd>
<dt>verbose_mode (optional) </dt>
<dd>BOOLEAN, default FALSE. Provides verbose_mode output of the results of training. </dd>
</dl>
<p><a class="anchor" id="train_mlogregr"></a></p><dl class="section user"><dt>Clustered Variance Multinomial Logistic Regression Training Function</dt><dd></dd></dl>
<pre class="syntax">
clustered_variance_mlogregr( source_table,
                             out_table,
                             dependent_varname,
                             independent_varname,
                             cluster_varname,
                             ref_category,
                             grouping_cols,
                             optimizer_params,
                             verbose_mode
                           )
</pre><p> <b>Arguments</b> </p><dl class="arglist">
<dt>source_table </dt>
<dd>TEXT. The name of the table containing the input data. </dd>
<dt>out_table </dt>
<dd><p class="startdd">TEXT. The name of the table where the regression model will be stored. The output table has the following columns: </p><table class="output">
<tr>
<th>category </th><td>The category.  </td></tr>
<tr>
<th>ref_category </th><td>The refererence category used for modeling.  </td></tr>
<tr>
<th>coef </th><td>Vector of the coefficients of the regression.  </td></tr>
<tr>
<th>std_err </th><td>Vector of the standard error of the coefficients.  </td></tr>
<tr>
<th>z_stats </th><td>Vector of the z-stats of the coefficients.  </td></tr>
<tr>
<th>p_values </th><td>Vector of the p-values of the coefficients.  </td></tr>
</table>
<p class="enddd">A summary table named &lt;out_table&gt;_summary is also created, which is the same as the summary table created by mlogregr_train function. Please refer to the documentation for multinomial logistic regression for details.  </p>
</dd>
<dt>dependent_varname </dt>
<dd>TEXT. An expression to evaluate for the dependent variable. </dd>
<dt>independent_varname </dt>
<dd>TEXT. An expression to evaluate for the independent variable. </dd>
<dt>cluster_varname </dt>
<dd>TEXT. A comma-separated list of columns to use as cluster variables. </dd>
<dt>ref_category (optional) </dt>
<dd>INTEGER. Reference category in the range [0, num_category). </dd>
<dt>groupingvarng_cols (optional) </dt>
<dd>TEXT, default: NULL. <em>Not yet implemented. Any non-NULL values are ignored.</em> A comma-separated list of columns to use as grouping variables. </dd>
<dt>optimizer_params (optional) </dt>
<dd>TEXT, default: NULL, which uses the default values of optimizer parameters: max_iter=20, optimizer='newton', tolerance=1e-4. It should be a string that contains pairs of 'key=value' separated by commas. </dd>
<dt>verbose_mode (optional) </dt>
<dd>BOOLEAN, default FALSE. If TRUE, detailed information is printed when computing logistic regression. </dd>
</dl>
<p><a class="anchor" id="train_cox"></a></p><dl class="section user"><dt>Clustered Variance for Cox Proportional Hazards model</dt><dd></dd></dl>
<p>The clustered robust variance estimator function for the Cox Proportional Hazards model has the following syntax. </p><pre class="syntax">
clustered_variance_coxph(model_table, output_table, clustervar)
</pre><p><b>Arguments</b> </p><dl class="arglist">
<dt>model_table </dt>
<dd>TEXT. The name of the model table, which is exactaly the same as the 'output_table' parameter of <a class="el" href="cox__prop__hazards_8sql__in.html#a737450bbfe0f10204b0074a9d45b0cef" title="Compute cox-regression coefficients and diagnostic statistics. ">coxph_train()</a> function. </dd>
<dt>output_table </dt>
<dd>TEXT. The name of the table where the output is saved. It has the following columns: <table class="output">
<tr>
<th>coef </th><td>FLOAT8[]. Vector of the coefficients.  </td></tr>
<tr>
<th>loglikelihood </th><td>FLOAT8. Log-likelihood value of the MLE estimate.  </td></tr>
<tr>
<th>std_err </th><td>FLOAT8[]. Vector of the standard error of the coefficients.  </td></tr>
<tr>
<th>clustervar </th><td>TEXT. A comma-separated list of columns to use as cluster variables.  </td></tr>
<tr>
<th>clustered_se </th><td>FLOAT8[]. Vector of the robust standard errors of the coefficients.  </td></tr>
<tr>
<th>clustered_z </th><td>FLOAT8[]. Vector of the robust z-stats of the coefficients.  </td></tr>
<tr>
<th>clustered_p </th><td>FLOAT8[]. Vector of the robust p-values of the coefficients.  </td></tr>
<tr>
<th>hessian </th><td>FLOAT8[]. The Hessian matrix.  </td></tr>
</table>
</dd>
<dt>clustervar </dt>
<dd>TEXT. A comma-separated list of columns to use as cluster variables. </dd>
</dl>
<p><a class="anchor" id="examples"></a></p><dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ol type="1">
<li>View online help for the clustered variance linear regression function. <pre class="example">
SELECT madlib.clustered_variance_linregr();
</pre></li>
<li>Run the linear regression function and view the results. <pre class="example">
DROP TABLE IF EXISTS out_table;
SELECT madlib.clustered_variance_linregr( 'abalone',
                                          'out_table',
                                          'rings',
                                          'ARRAY[1, diameter, length, width]',
                                          'sex',
                                          NULL
                                        );
SELECT * FROM out_table;
</pre></li>
<li>View online help for the clustered variance logistic regression function. <pre class="example">
SELECT madlib.clustered_variance_logregr();
</pre></li>
<li>Run the logistic regression function and view the results. <pre class="example">
DROP TABLE IF EXISTS out_table;
SELECT madlib.clustered_variance_logregr( 'abalone',
                                          'out_table',
                                          'rings &lt; 10',
                                          'ARRAY[1, diameter, length, width]',
                                          'sex'
                                        );
SELECT * FROM out_table;
</pre></li>
<li>View online help for the clustered variance multinomial logistic regression function. <pre class="example">
SELECT madlib.clustered_variance_mlogregr();
</pre></li>
<li>Run the multinomial logistic regression and view the results. <pre class="example">
DROP TABLE IF EXISTS out_table;
SELECT madlib.clustered_variance_mlogregr( 'abalone',
                                           'out_table',
                                           'CASE WHEN rings &lt; 10 THEN 1 ELSE 0 END',
                                           'ARRAY[1, diameter, length, width]',
                                           'sex',
                                           0
                                         );
SELECT * FROM out_table;
</pre></li>
<li>Run the Cox Proportional Hazards regression and compute the clustered robust estimator. <pre class="example">
DROP TABLE IF EXISTS lung_cl_out;
DROP TABLE IF EXISTS lung_out;
DROP TABLE IF EXISTS lung_out_summary;
SELECT madlib.coxph_train('lung',
                          'lung_out',
                          'time',
                          'array[age, "ph.ecog"]',
                          'TRUE',
                          NULL,
                          NULL);
SELECT madlib.clustered_variance_coxph('lung_out',
                                       'lung_cl_out',
                                       '"ph.karno"');
SELECT * FROM lung_cl_out;
</pre></li>
</ol>
<p><a class="anchor" id="notes"></a></p><dl class="section user"><dt>Notes</dt><dd></dd></dl>
<ul>
<li>Note that we need to manually include an intercept term in the independent variable expression. The NULL value of <em>groupingvar</em> means that there is no grouping in the calculation.</li>
</ul>
<p><a class="anchor" id="background"></a></p><dl class="section user"><dt>Technical Background</dt><dd></dd></dl>
<p>Assume that the data can be separated into <img class="formulaInl" alt="$m$" src="form_314.png"/> clusters. Usually this can be done by grouping the data table according to one or multiple columns.</p>
<p>The estimator has a similar form to the usual sandwich estimator </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ S(\vec{c}) = B(\vec{c}) M(\vec{c}) B(\vec{c}) \]" src="form_315.png"/>
</p>
<p>The bread part is the same as Huber-White sandwich estimator </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} B(\vec{c}) &amp; = &amp; \left(-\sum_{i=1}^{n} H(y_i, \vec{x}_i, \vec{c})\right)^{-1}\\ &amp; = &amp; \left(-\sum_{i=1}^{n}\frac{\partial^2 l(y_i, \vec{x}_i, \vec{c})}{\partial c_\alpha \partial c_\beta}\right)^{-1} \end{eqnarray}" src="form_316.png"/>
</p>
<p> where <img class="formulaInl" alt="$H$" src="form_317.png"/> is the hessian matrix, which is the second derivative of the target function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ L(\vec{c}) = \sum_{i=1}^n l(y_i, \vec{x}_i, \vec{c})\ . \]" src="form_318.png"/>
</p>
<p>The meat part is different </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M(\vec{c}) = \bf{A}^T\bf{A} \]" src="form_319.png"/>
</p>
<p> where the <img class="formulaInl" alt="$m$" src="form_314.png"/>-th row of <img class="formulaInl" alt="$\bf{A}$" src="form_320.png"/> is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_m = \sum_{i\in G_m}\frac{\partial l(y_i,\vec{x}_i,\vec{c})}{\partial \vec{c}} \]" src="form_321.png"/>
</p>
<p> where <img class="formulaInl" alt="$G_m$" src="form_322.png"/> is the set of rows that belong to the same cluster.</p>
<p>We can compute the quantities of <img class="formulaInl" alt="$B$" src="form_207.png"/> and <img class="formulaInl" alt="$A$" src="form_42.png"/> for each cluster during one scan through the data table in an aggregate function. Then sum over all clusters to the full <img class="formulaInl" alt="$B$" src="form_207.png"/> and <img class="formulaInl" alt="$A$" src="form_42.png"/> in the outside of the aggregate function. At last, the matrix mulplitications are done in a separate function on the master node.</p>
<p>When multinomial logistic regression is computed before the multinomial clustered variance calculation, it uses a default reference category of zero and the regression coefficients are included in the output table. The regression coefficients in the output are in the same order as multinomial logistic regression function, which is described below. For a problem with <img class="formulaInl" alt="$ K $" src="form_118.png"/> dependent variables <img class="formulaInl" alt="$ (1, ..., K) $" src="form_119.png"/> and <img class="formulaInl" alt="$ J $" src="form_120.png"/> categories <img class="formulaInl" alt="$ (0, ..., J-1) $" src="form_121.png"/>, let <img class="formulaInl" alt="$ {m_{k,j}} $" src="form_122.png"/> denote the coefficient for dependent variable <img class="formulaInl" alt="$ k $" src="form_98.png"/> and category <img class="formulaInl" alt="$ j $" src="form_123.png"/>. The output is <img class="formulaInl" alt="$ {m_{k_1, j_0}, m_{k_1, j_1} \ldots m_{k_1, j_{J-1}}, m_{k_2, j_0}, m_{k_2, j_1} \ldots m_{k_K, j_{J-1}}} $" src="form_323.png"/>. The order is NOT CONSISTENT with the multinomial regression marginal effect calculation with function <em>marginal_mlogregr</em>. This is deliberate because the interfaces of all multinomial regressions (robust, clustered, ...) will be moved to match that used in marginal.</p>
<p><a class="anchor" id="literature"></a></p><dl class="section user"><dt>Literature</dt><dd></dd></dl>
<p>[1] Standard, Robust, and Clustered Standard Errors Computed in R, <a href="http://diffuseprior.wordpress.com/2012/06/15/standard-robust-and-clustered-standard-errors-computed-in-r/">http://diffuseprior.wordpress.com/2012/06/15/standard-robust-and-clustered-standard-errors-computed-in-r/</a></p>
<p><a class="anchor" id="related"></a></p><dl class="section user"><dt>Related Topics</dt><dd>File <a class="el" href="clustered__variance_8sql__in.html">clustered_variance.sql_in</a> documenting the clustered variance SQL functions.</dd></dl>
<p>File <a class="el" href="clustered__variance__coxph_8sql__in.html" title="SQL functions for clustered robust cox proportional hazards regression. ">clustered_variance_coxph.sql_in</a> documenting the clustered variance for Cox proportional hazards SQL functions.</p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Mar 10 2017 16:46:57 for MADlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
