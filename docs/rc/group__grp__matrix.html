<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="keywords" content="madlib,postgres,greenplum,machine learning,data mining,deep learning,ensemble methods,data science,market basket analysis,affinity analysis,pca,lda,regression,elastic net,huber white,proportional hazards,k-means,latent dirichlet allocation,bayes,support vector machines,svm"/>
<title>MADlib: Matrix Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<!-- hack in the navigation tree -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="madlib_extra.css" rel="stylesheet" type="text/css"/>
<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45382226-1', 'madlib.apache.org');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://madlib.apache.org"><img alt="Logo" src="madlib.png" height="50" style="padding-left:0.5em;" border="0"/ ></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   <span id="projectnumber">1.20.0</span>
   </div>
   <div id="projectbrief">User Documentation for Apache MADlib</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__grp__matrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Matrix Operations<div class="ingroups"><a class="el" href="group__grp__datatrans.html">Data Types and Transformations</a> &raquo; <a class="el" href="group__grp__arraysmatrix.html">Arrays and Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><b>Contents</b> <ul>
<li class="level1">
<a href="#description">Description</a> </li>
<li class="level1">
<a href="#operations">Matrix Operations</a> </li>
<li class="level1">
<a href="#arguments">Arguments</a> </li>
<li class="level1">
<a href="#examples">Examples</a> </li>
<li class="level1">
<a href="#related">Related Topics</a> </li>
</ul>
</div><p><a class="anchor" id="description"></a>This module provides a set of basic matrix operations for matrices that are too big to fit in memory. We provide two storage formats for a matrix:</p>
<ul>
<li><b>Dense</b>: The matrix is represented as a distributed collection of 1-D arrays. An example 3x10 matrix would be the table below: <pre>
 row_id |         row_vec
--------+-------------------------
   1    | {9,6,5,8,5,6,6,3,10,8}
   2    | {8,2,2,6,6,10,2,1,9,9}
   3    | {3,9,9,9,8,6,3,9,5,6}
</pre></li>
</ul>
<p>A '<em>row</em>' column (called <em>row_id</em> above) provides the row number of each row and a '<em>val</em>' column (called <em>row_vec</em> above) provides each row as an array. <b>The <em>row</em> column should contain a series of integers from 1 to <em>N</em> with no duplicates, where <em>N</em> is the row dimensionality</b>.</p>
<ul>
<li><b>Sparse</b>: The matrix is represented using the row and column indices for each non-zero entry of the matrix. This representation is useful for sparse matrices, containing multiple zero elements. Given below is an example of a sparse 4x7 matrix with just 6 out of 28 entries being non-zero. The dimensionality of the matrix is inferred using the max value in <em>row</em> and <em>col</em> columns. Note the last entry is included (even though it is 0) to provide the dimensionality of the matrix, indicating that the 4th row and 7th column contain all zeros. <pre>
 row_id | col_id | value
--------+--------+-------
      1 |      1 |     9
      1 |      5 |     6
      1 |      6 |     6
      2 |      1 |     8
      3 |      1 |     3
      3 |      2 |     9
      4 |      7 |     0
(6 rows)
</pre></li>
</ul>
<p><b>For sparse matrices, the <em>row</em> and <em>col</em> columns together should not contain a duplicate entry and the <em>val</em> column should be of scalar (non-array) data type</b>. <br />
 For comparison, the dense representation of this matrix is shown below. Note the dimensionality of the dense matrix is 4 x 7 since the max value of <em>row</em> and <em>col</em> is 4 and 7 respectively, leading to all zeros in the last row and last column. &#160; </p><pre>
 row_id |         row_vec
--------+-------------------------
   1    | {9,0,0,0,6,6,0}
   2    | {8,0,0,0,0,0,0}
   3    | {3,9,0,0,0,0,0}
   4    | {0,0,0,0,0,0,0}
</pre><dl class="section note"><dt>Note</dt><dd>The functions below support several numeric types (unless otherwise noted) including SMALLINT, INTEGER, BIGINT, DOUBLE PRECISION (FLOAT8), NUMERIC (internally casted into FLOAT8, so loss of precision can happen).</dd></dl>
<p><a class="anchor" id="operations"></a></p><dl class="section user"><dt>Matrix Operations</dt><dd></dd></dl>
<p>Below are the supported matrix operations. The meaning of the arguments and other terms are common to all functions and are provided at the end of the list in the glossary of arguments.</p>
<ul>
<li><b>Representation</b> <pre class="syntax">
-- Convert to sparse representation
&#160; <b>matrix_sparsify</b>( matrix_in, in_args, matrix_out, out_args)
&#160;
-- Convert to dense representation
&#160; <b>matrix_densify</b>( matrix_in, in_args, matrix_out, out_args)
&#160;
-- Get dimensions of matrix
&#160; <b>matrix_ndims</b>( matrix_in, in_args )
</pre></li>
<li><b>Mathematical operations</b> <pre class="syntax">
-- Matrix transposition
&#160; <b>matrix_trans</b>( matrix_in, in_args, matrix_out, out_args)
&#160;
-- Matrix addition
&#160; <b>matrix_add</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&#160;
-- Matrix subtraction
&#160; <b>matrix_sub</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&#160;
-- Matrix multiplication
&#160; <b>matrix_mult</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&#160;
-- Element-wise matrix multiplication
&#160; <b>matrix_elem_mult</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&#160;
-- Multiply matrix with scalar
&#160; <b>matrix_scalar_mult</b>( matrix_in, in_args, scalar, matrix_out, out_args)
&#160;
-- Multiply matrix with vector
&#160; <b>matrix_vec_mult</b>( matrix_in, in_args, vector)
</pre></li>
<li><b>Extraction/visitor methods</b> <pre class="syntax">
-- Extract row from matrix given row index
&#160; <b>matrix_extract_row</b>( matrix_in, in_args, index)
&#160;
-- Extract column from matrix given column index
&#160; <b>matrix_extract_col</b>( matrix_in, in_args, index)
&#160;
-- Extract main (principal) diagonal elements
&#160; <b>matrix_extract_diag</b>( matrix_in, in_args)
</pre></li>
<li><b>Reduction operations (aggregate across specific dimension)</b> <pre class="syntax">
-- Get max value along dim. Returns corresponding index if <em>fetch_index</em> = True
&#160; <b>matrix_max</b>( matrix_in, in_args, dim, matrix_out, fetch_index)
&#160;
-- Get min value along dim. Returns corresponding index if <em>fetch_index</em> = True
&#160; <b>matrix_min</b>( matrix_in, in_args, dim, matrix_out, fetch_index)
&#160;
-- Get sum value along dimension
&#160; <b>matrix_sum</b>( matrix_in, in_args, dim)
&#160;
-- Get mean value along dimension
&#160; <b>matrix_mean</b>( matrix_in, in_args, dim)
&#160;
-- Get matrix norm
&#160; <b>matrix_norm</b>( matrix_in, in_args, norm_type)
</pre></li>
<li><b>Creation methods</b> <pre class="syntax">
-- Create a matrix initialized with ones of given row and column dimension
&#160; <b>matrix_ones</b>( row_dim, col_dim, matrix_out, out_args)
&#160;
-- Create a matrix initialized with zeros of given row and column dimension
&#160; <b>matrix_zeros</b>( row_dim, col_dim, matrix_out, out_args)
&#160;
-- Create an square identity matrix of size dim x dim
&#160; <b>matrix_identity</b>( dim, matrix_out, out_args)
&#160;
-- Create a diag matrix initialized with given diagonal elements
&#160; <b>matrix_diag</b>( diag_elements, matrix_out, out_args)
-- Create a matrix initialized with values sampled from a distribution
-- Supported distributions: normal, uniform, bernoulli
&#160; <b>matrix_random</b>( distribution, row_dim, col_dim, in_args, matrix_out, out_args )
</pre></li>
<li><b>Decomposition operations</b> <dl class="section note"><dt>Note</dt><dd>Please note that the decomposition operations below are only implemented for in-memory operations. The matrix data is collected on a single node and the decomposition is computed. This makes the operations applicable to smaller matrices since the calculation is not distributed across multiple nodes.</dd></dl>
<pre class="syntax">
-- Matrix inverse
&#160; <b>matrix_inverse</b>( matrix_in, in_args, matrix_out, out_args)
&#160;
-- Matrix generic inverse
&#160; <b>matrix_pinv</b>( matrix_in, in_args, matrix_out, out_args)
&#160;
-- Matrix eigenvalue extraction
&#160; <b>matrix_eigen</b>( matrix_in, in_args, matrix_out, out_args)
&#160;
-- Matrix Cholesky decomposition
&#160; <b>matrix_cholesky</b>( matrix_in, in_args, matrix_out_prefix, out_args)
&#160;
-- Matrix QR decomposition
&#160; <b>matrix_qr</b>( matrix_in, in_args, matrix_out_prefix, out_args)
&#160;
-- Matrix LU decomposition
&#160; <b>matrix_lu</b>( matrix_in, in_args, matrix_out_prefix, out_args)
&#160;
-- Matrix nuclear norm computing
&#160; <b>matrix_nuclear_norm</b>( matrix_in, in_args)
&#160;
-- Matrix rank computing
&#160; <b>matrix_rank</b>( matrix_in, in_args)
</pre></li>
</ul>
<p><a class="anchor" id="arguments"></a><b>Arguments</b> </p>
<p>The table below provides a glossary of the arguments used in the matrix operations.</p>
<dl class="arglist">
<dt>matrix_in, matrix_a, matrix_b </dt>
<dd><p class="startdd">TEXT. Name of the table containing the input matrix.</p><ul>
<li>For functions accepting one matrix, <em>matrix_in</em> denotes the input matrix.</li>
<li>For functions accepting two matrices, <em>matrix_a</em> denotes the first matrix and <em>matrix_b</em> denotes the second matrix. These two matrices can <b>independently</b> be in either dense or sparse format. </li>
</ul>
<p class="enddd"></p>
</dd>
<dt>in_args, a_args, b_args </dt>
<dd><p class="startdd">TEXT. A comma-delimited string containing multiple named arguments of the form "name=value". This argument is used as a container for multiple parameters related to a single matrix.</p>
<p>The following parameters are supported for this string argument: </p><table class="output">
<tr>
<th>row </th><td>(Default: 'row_num') Name of the column containing row index of the matrix.   </td></tr>
<tr>
<th>col </th><td>(Default: 'col_num') Name of the column containing column index of the matrix.  </td></tr>
<tr>
<th>val </th><td>(Default: 'val') Name of the column containing the entries of the matrix.  </td></tr>
<tr>
<th>trans </th><td>(Default: False) Boolean flag to indicate if the matrix should be transposed before the operation. This is currently functional only for <em>matrix_mult</em>.  </td></tr>
</table>
<p>For example, the string argument with default values will be 'row=row_num, col=col_num, val=val, trans=False'. Alternatively, the string argument can be set to <em>NULL</em> or be blank ('') if default values are to be used. </p>
<p class="enddd"></p>
</dd>
<dt>matrix_out </dt>
<dd><p class="startdd">TEXT. Name of the table to store the result matrix.</p>
<p>For Cholesky, QR and LU decompositions, a prefix (<em>matrix_out_prefix</em>) is used as a basis to build the names of the various output tables.</p>
<p>For Cholesky decomposition ( \( PA = LDL* \)), the following suffixes are added to <em>matrix_out_prefix</em>:</p><ul>
<li><em>_p</em> for row permutation matrix P</li>
<li><em>_l</em> for lower triangular factor L</li>
<li><em>_d</em> for diagonal matrix D</li>
</ul>
<p>For QR decomposition ( \( A = QR \)) the following suffixes are added to <em>matrix_out_prefix</em>:</p><ul>
<li><em>_q</em> for orthogonal matrix Q</li>
<li><em>_r</em> for upper triangular factor R</li>
</ul>
<p>For LU decomposition with full pivoting ( \( PAQ = LU \)), the following suffixes are added to <em>matrix_out_prefix</em>:</p><ul>
<li><em>_p</em> for row permutation matrix P</li>
<li><em>_q</em> for column permutation matrix Q</li>
<li><em>_l</em> for lower triangular factor L</li>
<li><em>_u</em> for upper triangular factor U </li>
</ul>
<p class="enddd"></p>
</dd>
<dt>out_args </dt>
<dd><p class="startdd">TEXT. A comma-delimited string containing named arguments of the form "name=value". This is an <b>optional parameter</b> and the default value is set as follows:</p><ul>
<li>For functions with one input matrix, default <em>out_args</em> will the be same as specified in <em>in_args</em>.</li>
<li>For functions with two input matrices, default <em>out_args</em> will be the same as specified in <em>a_args</em>.</li>
</ul>
<p>The following parameters are supported for this string argument: </p><table class="output">
<tr>
<th>row </th><td>Name of the column containing row index of the matrix.   </td></tr>
<tr>
<th>col </th><td>Name of the column containing column index of the matrix.  </td></tr>
<tr>
<th>val </th><td>Name of the column containing the entries of the matrix.  </td></tr>
<tr>
<th>fmt </th><td>Format of the output matrix. It could be either 'dense' or 'sparse'. When 'fmt' is not provided, the output fmt is inferred from the input matrices.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>One exception is for <em>matrix_eigen</em>: the default output column name is <em>’eigen_values’</em> in the format <em>(real, imaginary)</em>.</dd></dl>
</dd>
<dt>index </dt>
<dd><p class="startdd">INTEGER. An integer representing a row or column index of the matrix. Should be a number from 1 to <em>N</em>, where <em>N</em> is the maximum size of the dimension.</p>
<p class="enddd"></p>
</dd>
<dt>dim </dt>
<dd><p class="startdd">INTEGER. Should either be 1 or 2. This value indicates the dimension to operate along for the reduction/aggregation operations. <b>The value of <em>dim</em> should be interpreted as the dimension to be flattened i.e. whose length reduces to 1 in the result.</b></p>
<p>For any reduction function applied on an <em>N x M</em> matrix:</p>
<ul>
<li>if <em>dim=1</em>, operation is applied on successive elements in each column; return value is a single vector with <em>M</em> elements (i.e. matrix with 1 row and <em>M</em> columns). <br />
</li>
<li>if <em>dim=2</em>, operation is applied on successive elements in each row; return value is a single vector with <em>N</em> elements (i.e. matrix with <em>N</em> rows and 1 column). </li>
</ul>
<p class="enddd"></p>
</dd>
<dt>row_dim </dt>
<dd><p class="startdd">INTEGER. Should be greater than 0. This value indicates the row dimension of result matrix. </p>
<p class="enddd"></p>
</dd>
<dt>col_dim </dt>
<dd><p class="startdd">INTEGER. Should be greater than 0. This value indicates the column dimension of result matrix. </p>
<p class="enddd"></p>
</dd>
<dt>diag_elements </dt>
<dd><p class="startdd">ARRAY OF FLOAT. Should not be empty. This value indicates the float array which is used to generate diag elements of result output matrix. </p>
<p class="enddd"></p>
</dd>
<dt>norm_type </dt>
<dd><p class="startdd">TEXT. Optional parameter. Defaults to Frobenius norm. Other supported norms for this string argument:</p>
<table class="output">
<tr>
<th>'one' or 'o' </th><td>1 norm   </td></tr>
<tr>
<th>float &gt; 0 </th><td>Element-wise norm  </td></tr>
<tr>
<th>'inf' or 'i' </th><td>Infinite norm  </td></tr>
<tr>
<th>'max' or 'm' </th><td>Max absolute value norm  </td></tr>
<tr>
<th>'fro' or 'f' </th><td>Frobenius norm (default)  </td></tr>
</table>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="examples"></a></p><dl class="section user"><dt>Examples (Dense Format)</dt><dd></dd></dl>
<p>Here are some examples of matrix operations in dense format. Later on this page we will show examples of matrix operations in sparse format.</p>
<ol type="1">
<li>First let’s create example data tables in dense format: <pre class="syntax">
CREATE TABLE "mat_A" (
        row_id integer,
        row_vec integer[]
);
INSERT INTO "mat_A" (row_id, row_vec) VALUES (1, '{9,6,5,8,5,6,6,3,10,8}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (2, '{8,2,2,6,6,10,2,1,9,9}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (3, '{3,9,9,9,8,6,3,9,5,6}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (4, '{6,4,2,2,2,7,8,8,0,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (5, '{6,8,9,9,4,6,9,5,7,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (6, '{4,10,7,3,9,5,9,2,3,4}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (7, '{8,10,7,10,1,9,7,9,8,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (8, '{7,4,5,6,2,8,1,1,4,8}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (9, '{8,8,8,5,2,6,9,1,8,3}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (10, '{4,6,3,2,6,4,1,2,3,8}');

CREATE TABLE "mat_B" (
    row_id integer,
    vector integer[]
);
INSERT INTO "mat_B" (row_id, vector) VALUES (1, '{9,10,2,4,6,5,3,7,5,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (2, '{5,3,5,2,8,6,9,7,7,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (3, '{0,1,2,3,2,7,7,3,10,1}');
INSERT INTO "mat_B" (row_id, vector) VALUES (4, '{2,9,0,4,3,6,8,6,3,4}');
INSERT INTO "mat_B" (row_id, vector) VALUES (5, '{3,8,7,7,0,5,3,9,2,10}');
INSERT INTO "mat_B" (row_id, vector) VALUES (6, '{5,3,1,7,6,3,5,3,6,4}');
INSERT INTO "mat_B" (row_id, vector) VALUES (7, '{4,8,4,4,2,7,10,0,3,3}');
INSERT INTO "mat_B" (row_id, vector) VALUES (8, '{4,6,0,1,3,1,6,6,9,8}');
INSERT INTO "mat_B" (row_id, vector) VALUES (9, '{6,5,1,7,2,7,10,6,0,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (10, '{1,4,4,4,8,5,2,8,5,5}');
</pre></li>
<li>Transpose a matrix <pre class="syntax">
SELECT madlib.matrix_trans('"mat_B"', 'row=row_id, val=vector',
                           'mat_r');
SELECT * FROM mat_r ORDER BY row_id;
</pre> <pre class="result">
-- Note that the result matrix has inherited 'vector' as the name of the value column by default
 row_id |         vector
--------+-------------------------
      1 | {9,5,0,2,3,5,4,4,6,1}
      2 | {10,3,1,9,8,3,8,6,5,4}
      3 | {2,5,2,0,7,1,4,0,1,4}
      4 | {4,2,3,4,7,7,4,1,7,4}
      5 | {6,8,2,3,0,6,2,3,2,8}
      6 | {5,6,7,6,5,3,7,1,7,5}
      7 | {3,9,7,8,3,5,10,6,10,2}
      8 | {7,7,3,6,9,3,0,6,6,8}
      9 | {5,7,10,3,2,6,3,9,0,5}
      10 | {6,6,1,4,10,4,3,8,6,5}
(10 rows)
</pre></li>
<li>Extract main diagonal of a matrix <pre class="syntax">
SELECT madlib.matrix_extract_diag('"mat_B"', 'row=row_id, val=vector');
</pre> <pre class="result">
-- Note the result is an array
         matrix_extract_diag
---------------------------------
{9,3,2,4,0,3,10,6,0,5}
(1 row)
</pre></li>
<li>Add two matrices <pre class="syntax">
SELECT madlib.matrix_add('"mat_A"', 'row=row_id, val=row_vec',
                         '"mat_B"', 'row=row_id, val=vector',
                         'mat_r', 'val=vector, fmt=dense');
SELECT * FROM mat_r ORDER BY row_id;
</pre> <pre class="result">
 row_id |            vector
--------+-------------------------------
      1 | {18,16,7,12,11,11,9,10,15,14}
      2 | {13,5,7,8,14,16,11,8,16,15}
      3 | {3,10,11,12,10,13,10,12,15,7}
      4 | {8,13,2,6,5,13,16,14,3,11}
      5 | {9,16,16,16,4,11,12,14,9,17}
      6 | {9,13,8,10,15,8,14,5,9,8}
      7 | {12,18,11,14,3,16,17,9,11,10}
      8 | {11,10,5,7,5,9,7,7,13,16}
      9 | {14,13,9,12,4,13,19,7,8,9}
      10 | {5,10,7,6,14,9,3,10,8,13}
(10 rows)
</pre></li>
<li>Multiply two matrices <pre class="syntax">
SELECT madlib.matrix_mult('"mat_A"', 'row=row_id, val=row_vec',
                          '"mat_B"', 'row=row_id, val=vector, trans=true',
                          'mat_r');
SELECT * FROM mat_r ORDER BY row_id;
</pre> <pre class="result">
 row_id |                  row_vec
--------+-------------------------------------------
     1  | {380,373,251,283,341,303,302,309,323,281}
     2  | {318,318,222,221,269,259,236,249,264,248}
     3  | {382,366,216,300,397,276,277,270,313,338}
     4  | {275,284,154,244,279,183,226,215,295,204}
     5  | {381,392,258,319,394,298,342,302,360,300}
     6  | {321,333,189,276,278,232,300,236,281,250}
     7  | {443,411,282,365,456,318,360,338,406,330}
     8  | {267,240,150,186,270,194,210,184,233,193}
     9  | {322,328,234,264,291,245,317,253,291,219}
     10 | {246,221,109,173,222,164,167,185,181,189}
(10 rows)
</pre></li>
<li>Create a diagonal matrix <pre class="syntax">
SELECT madlib.matrix_diag(array[9,6,3,10],
                          'mat_r', 'row=row_id, col=col_id, val=val');
SELECT * FROM mat_r ORDER BY row_id::bigint;
</pre> <pre class="result">
 row_id | col_id  |  val
--------+---------+--------
      1 |       1 |      9
      2 |       2 |      6
      3 |       3 |      3
      4 |       4 |     10
(11 rows)
</pre></li>
<li>Create an identity matrix <pre class="syntax">
SELECT madlib.matrix_identity(4, 'mat_r', 'row=row_id,col=col_id,val=val');
SELECT * FROM mat_r ORDER BY row_id;
</pre> <pre class="result">
 row_id | col_id  |  val
--------+---------+--------
      1 |       1 |      1
      2 |       2 |      1
      3 |       3 |      1
      4 |       4 |      1
(5 rows)
</pre></li>
<li>Extract row and column from a matrix by specifying index <pre class="syntax">
SELECT madlib.matrix_extract_row('"mat_A"', 'row=row_id, val=row_vec', 2) as row,
       madlib.matrix_extract_col('"mat_A"', 'row=row_id, val=row_vec', 3) as col;
</pre> <pre class="result">
          row           |          col
------------------------+-----------------------
 {8,2,2,6,6,10,2,1,9,9} | {5,2,9,2,9,7,7,5,8,3}
(1 rows)
</pre></li>
<li>Get min and max values along a specific dimension, as well as the corresponding indices. Note that in this example <em>dim=2</em> implies that the min and max is computed on each row, returning a column vector i.e. the column (dim=2) is flattened. <pre class="syntax">
SELECT madlib.matrix_max('"mat_A"', 'row=row_id, val=row_vec', 2, 'mat_max_r', true),
       madlib.matrix_min('"mat_A"', 'row=row_id, val=row_vec', 2, 'mat_min_r', true);
SELECT * from mat_max_r;
SELECT * from mat_min_r;
</pre> <pre class="result">
         index         |            max
-----------------------+---------------------------
 {9,6,2,7,3,2,2,6,7,10} | {10,10,9,8,9,10,10,8,9,8}
(1 rows)
&#160;
         index         |          min
-----------------------+-----------------------
 {8,8,1,9,5,8,5,7,8,7} | {3,1,3,0,4,2,1,1,1,1}
(1 rows)
</pre></li>
<li>Initialize matrix with zeros in sparse format <pre class="syntax">
SELECT madlib.matrix_zeros(5, 4, 'mat_r', 'row=row_id, col=col_id, val=entry');
SELECT * FROM mat_r;
</pre> <pre class="result">
 row_id |  col_id | entry
--------+---------+--------
      5 |       4 |    0
(1 rows)
</pre></li>
<li>Initialize matrix with zeros in dense format  <pre class="syntax">
SELECT madlib.matrix_zeros(5, 4, 'mat_r', 'fmt=dense');
SELECT * FROM mat_r ORDER BY row;
</pre> <pre class="result">
  row |    val
-----+-----------
   1 | {0,0,0,0}
   2 | {0,0,0,0}
   3 | {0,0,0,0}
   4 | {0,0,0,0}
   5 | {0,0,0,0}
(5 rows)
</pre></li>
<li>Initialize matrix with ones  <pre class="syntax">
SELECT madlib.matrix_ones(5, 4, 'mat_r', 'row=row,col=col, val=val');
SELECT * FROM mat_r;
</pre> <pre class="result">
 row | col | val
-----+-----+-----
   1 |   1 |   1
   1 |   2 |   1
   1 |   3 |   1
   1 |   4 |   1
   2 |   1 |   1
   2 |   2 |   1
   2 |   3 |   1
   2 |   4 |   1
   3 |   1 |   1
   3 |   2 |   1
   3 |   3 |   1
   3 |   4 |   1
   4 |   1 |   1
   4 |   2 |   1
   4 |   3 |   1
   4 |   4 |   1
   5 |   1 |   1
   5 |   2 |   1
   5 |   3 |   1
   5 |   4 |   1
(20 rows)
</pre></li>
<li>Initialize matrix with ones in dense format  <pre class="syntax">
SELECT madlib.matrix_ones(5, 4, 'mat_r', 'fmt=dense');
SELECT * FROM mat_r ORDER BY row;
</pre> <pre class="result">
  row |    val
-----+-----------
   1 | {1,1,1,1}
   2 | {1,1,1,1}
   3 | {1,1,1,1}
   4 | {1,1,1,1}
   5 | {1,1,1,1}
(5 rows)
</pre></li>
<li>Element-wise multiplication between two matrices <pre class="syntax">
SELECT madlib.matrix_elem_mult('"mat_A"', 'row=row_id, val=row_vec',
                               '"mat_B"', 'row=row_id, val=vector',
                               'mat_r', 'val=vector');
SELECT * FROM mat_r ORDER BY row_id;
</pre> <pre class="result">
 row_id |             vector
--------+---------------------------------
     1  | {81,60,10,32,30,30,18,21,50,48}
     2  | {40,6,10,12,48,60,18,7,63,54}
     3  | {0,9,18,27,16,42,21,27,50,6}
     4  | {12,36,0,8,6,42,64,48,0,28}
     5  | {18,64,63,63,0,30,27,45,14,70}
     6  | {20,30,7,21,54,15,45,6,18,16}
     7  | {32,80,28,40,2,63,70,0,24,21}
     8  | {28,24,0,6,6,8,6,6,36,64}
     9  | {48,40,8,35,4,42,90,6,0,18}
     10 | {4,24,12,8,48,20,2,16,15,40}
</pre></li>
<li>Get sum values along a dimension. In this example, the sum is computed for each row (i.e. column is flattened since dim=2). <pre class="syntax">
SELECT madlib.matrix_sum('"mat_A"', 'row=row_id, val=row_vec', 2);
</pre> <pre class="result">
           matrix_sum
---------------------------------
 {66,55,67,46,70,56,76,46,58,39}
(1 rows)
</pre></li>
<li>Get mean values along dimension <pre class="syntax">
SELECT madlib.matrix_mean('"mat_A"', 'row=row_id, val=row_vec', 2);
</pre> <pre class="result">
               matrix_mean
-----------------------------------------
 {6.6,5.5,6.7,4.6,7,5.6,7.6,4.6,5.8,3.9}
(1 rows)
</pre></li>
<li>Compute matrix norm. In this example, we ask for the Euclidean norm: <pre class="syntax">
SELECT madlib.matrix_norm('"mat_A"', 'row=row_id, val=row_vec', '2');
</pre> <pre class="result">
  matrix_norm
---------------
 64.1014820421
(1 row)
</pre></li>
<li>Multiply matrix with scalar <pre class="syntax">
SELECT madlib.matrix_scalar_mult('"mat_A"', 'row=row_id, val=row_vec', 3, 'mat_r');
SELECT * FROM mat_r ORDER BY row_id;
</pre> <pre class="result">
 row_id |             row_vec
--------+---------------------------------
      1 | {27,18,15,24,15,18,18,9,30,24}
      2 | {24,6,6,18,18,30,6,3,27,27}
      3 | {9,27,27,27,24,18,9,27,15,18}
      4 | {18,12,6,6,6,21,24,24,0,21}
      5 | {18,24,27,27,12,18,27,15,21,21}
      6 | {12,30,21,9,27,15,27,6,9,12}
      7 | {24,30,21,30,3,27,21,27,24,21}
      8 | {21,12,15,18,6,24,3,3,12,24}
      9 | {24,24,24,15,6,18,27,3,24,9}
     10 | {12,18,9,6,18,12,3,6,9,24}
(10 rows)
</pre></li>
<li>Get the row dimension and column dimension of matrix <pre class="syntax">
SELECT madlib.matrix_ndims('"mat_A"', 'row=row_id, val=row_vec');
</pre> <pre class="result">
 matrix_ndims
--------------
 {10,10}
(1 row)
</pre></li>
<li>Multiply matrix with vector <pre class="syntax">
SELECT madlib.matrix_vec_mult('"mat_A"', 'row=row_id, val=row_vec',
                              array[1,2,3,4,5,6,7,8,9,10]);
</pre> <pre class="result">
              matrix_vec_mult
-------------------------------------------
 {365,325,358,270,377,278,411,243,287,217}
(10 rows)
</pre></li>
<li>Inverse of matrix <pre class="syntax">
SELECT madlib.matrix_inverse('"mat_A"', 'row=row_id, val=row_vec', 'mat_r');
SELECT row_vec FROM mat_r ORDER BY row_id;
</pre></li>
<li>Generic inverse of matrix <pre class="syntax">
SELECT madlib.matrix_pinv('"mat_A"', 'row=row_id, val=row_vec', 'mat_r');
SELECT row_vec FROM mat_r ORDER BY row_id;
</pre></li>
<li>Eigenvalues of matrix (note default column name of eigenvalues) <pre class="syntax">
SELECT madlib.matrix_eigen('"mat_A"', 'row=row_id, val=row_vec', 'mat_r');
SELECT eigen_values FROM mat_r ORDER BY row_id;
</pre></li>
<li>Cholesky decomposition of matrix <pre class="syntax">
SELECT madlib.matrix_cholesky('"mat_A"', 'row=row_id, val=row_vec', 'matrix_out_prefix');
SELECT row_vec FROM matrix_out_prefix_p ORDER BY row_id;
SELECT row_vec FROM matrix_out_prefix_l ORDER BY row_id;
SELECT row_vec FROM matrix_out_prefix_d ORDER BY row_id;
</pre></li>
<li>QR decomposition of matrix <pre class="syntax">
SELECT madlib.matrix_qr('"mat_A"', 'row=row_id, val=row_vec', 'matrix_out_prefix');
SELECT row_vec FROM matrix_out_prefix_q ORDER BY row_id;
SELECT row_vec FROM matrix_out_prefix_r ORDER BY row_id;
</pre></li>
<li>LU decomposition of matrix <pre class="syntax">
SELECT madlib.matrix_lu('"mat_A"', 'row=row_id, val=row_vec', 'matrix_out_prefix');
SELECT row_vec FROM matrix_out_prefix_l ORDER BY row_id;
SELECT row_vec FROM matrix_out_prefix_u ORDER BY row_id;
SELECT row_vec FROM matrix_out_prefix_p ORDER BY row_id;
SELECT row_vec FROM matrix_out_prefix_q ORDER BY row_id;
</pre></li>
<li>Nuclear norm of matrix <pre class="syntax">
SELECT madlib.matrix_nuclear_norm('"mat_A"', 'row=row_id, val=row_vec');
</pre> <pre class="result">
 matrix_nuclear_norm
---------------------
       118.852685995
(1 row)
</pre></li>
<li>Rank of matrix <pre class="syntax">
SELECT madlib.matrix_rank('"mat_A"', 'row=row_id, val=row_vec');
</pre> <pre class="result">
 matrix_rank
-------------
          10
(1 row)
</pre></li>
</ol>
<dl class="section user"><dt>Examples (Sparse Format)</dt><dd></dd></dl>
<p>Below are some examples of matrix operations in sparse format.</p>
<ol type="1">
<li>Convert a matrix from dense to sparse format <pre class="syntax">
SELECT madlib.matrix_sparsify('"mat_B"', 'row=row_id, val=vector',
                              '"mat_B_sparse"', 'col=col_id, val=val');
SELECT * FROM "mat_B_sparse" ORDER BY row_id, col_id;
</pre></li>
<li>Create a matrix in sparse format. <pre class="syntax">
CREATE TABLE "mat_A_sparse" (
    "rowNum" integer,
    col_num integer,
    entry integer
);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 1, 9);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 2, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 7, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 8, 10);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 9, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 1, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 2, 2);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 3, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (3, 5, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (3, 6, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (7, 1, 7);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (8, 2, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (8, 3, 5);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (9, 1, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (9, 2, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (10, 10, 0);
</pre></li>
<li>Get the row_dims and col_dims of a matrix in sparse format <pre class="syntax">
SELECT madlib.matrix_ndims('"mat_A_sparse"', 'row="rowNum", val=entry')
</pre> <pre class="result">
 matrix_ndims
--------------
 {10,10}
(1 row)
</pre></li>
<li>Transpose a matrix in sparse format <pre class="syntax">
-- Note the double quotes for "rowNum" are required as per PostgreSQL rules since “N” is capitalized
SELECT madlib.matrix_trans('"mat_A_sparse"', 'row="rowNum", val=entry',
                           'matrix_r_sparse');
SELECT "rowNum", col_num, entry FROM matrix_r_sparse ORDER BY col_num;
</pre> <pre class="result">
 rowNum | col_num | entry
--------+---------+-------
      1 |       1 |     9
      2 |       1 |     6
      7 |       1 |     3
      8 |       1 |    10
      9 |       1 |     8
      1 |       2 |     8
      2 |       2 |     2
      3 |       2 |     6
      5 |       3 |     6
      6 |       3 |     3
      1 |       7 |     7
      2 |       8 |     8
      3 |       8 |     5
      1 |       9 |     6
      2 |       9 |     3
     10 |      10 |     0
(16 rows)
</pre></li>
<li>Main diagonal of a matrix in sparse format <pre class="syntax">
SELECT madlib.matrix_extract_diag('"mat_A_sparse"', 'row="rowNum", val=entry');
</pre> <pre class="result">
 matrix_extract_diag
-----------------
{9,2,0,0,0,0,0,0,0,0}
(1 row)
</pre></li>
<li>Add two sparse matrices then convert to dense format <pre class="syntax">
SELECT madlib.matrix_add('"mat_A_sparse"', 'row="rowNum", val=entry',
                         '"mat_B_sparse"', 'row=row_id, col=col_id, val=val',
                         'matrix_r_sparse', 'col=col_out');
SELECT madlib.matrix_densify('matrix_r_sparse', 'row="rowNum", col=col_out, val=entry',
                             'matrix_r');
SELECT * FROM matrix_r ORDER BY "rowNum";
</pre> <pre class="result">
 rowNum |           entry
--------+---------------------------
      1 | {18,16,2,4,6,5,6,17,13,6}
      2 | {13,5,11,2,8,6,9,7,7,6}
      3 | {0,1,2,3,8,10,7,3,10,1}
      4 | {2,9,0,4,3,6,8,6,3,4}
      5 | {3,8,7,7,0,5,3,9,2,10}
      6 | {5,3,1,7,6,3,5,3,6,4}
      7 | {11,8,4,4,2,7,10,0,3,3}
      8 | {4,14,5,1,3,1,6,6,9,8}
      9 | {12,8,1,7,2,7,10,6,0,6}
     10 | {1,4,4,4,8,5,2,8,5,5}
(10 rows)
</pre></li>
<li>Multiply two sparse matrices <pre class="syntax">
SELECT madlib.matrix_mult('"mat_A_sparse"', 'row="rowNum", col=col_num, val=entry',
                          '"mat_B_sparse"', 'row=row_id, col=col_id, val=val, trans=true',
                          'matrix_r');
SELECT * FROM matrix_r ORDER BY "rowNum";
</pre> <pre class="result">
 rowNum |                   entry
--------+-------------------------------------------
      1 | {260,216,137,180,190,156,138,222,174,159}
      2 | {104,76,14,34,82,52,72,44,64,40}
      3 | {51,66,33,36,15,45,33,21,33,63}
      4 | {0,0,0,0,0,0,0,0,0,0}
      5 | {0,0,0,0,0,0,0,0,0,0}
      6 | {0,0,0,0,0,0,0,0,0,0}
      7 | {63,35,0,14,21,35,28,28,42,7}
      8 | {90,49,18,72,99,29,84,48,45,52}
      9 | {84,39,3,39,42,39,48,42,51,18}
     10 | {0,0,0,0,0,0,0,0,0,0}
(10 rows)
</pre></li>
<li>Initialize matrix with ones  <pre class="syntax">
SELECT madlib.matrix_ones(5, 4, 'mat_r', 'row=row,col=col, val=val');
SELECT * FROM mat_r ORDER BY row, col;
</pre> <pre class="result">
 row | col | val
-----+-----+-----
   1 |   1 |   1
   1 |   2 |   1
   1 |   3 |   1
   1 |   4 |   1
   2 |   1 |   1
   2 |   2 |   1
   2 |   3 |   1
   2 |   4 |   1
   3 |   1 |   1
   3 |   2 |   1
   3 |   3 |   1
   3 |   4 |   1
   4 |   1 |   1
   4 |   2 |   1
   4 |   3 |   1
   4 |   4 |   1
   5 |   1 |   1
   5 |   2 |   1
   5 |   3 |   1
   5 |   4 |   1
(20 rows)
</pre></li>
<li>Initialize matrix with zeros in sparse format  <pre class="syntax">
SELECT madlib.matrix_zeros(5, 4, 'mat_r', 'row=row_id, col=col_id, val=entry');
SELECT * FROM mat_r;
</pre> <pre class="result">
 row_id |  col_id | entry
--------+---------+--------
      5 |       4 |    0
(1 rows)
</pre></li>
<li>Compute matrix norm on sparse matrix. In this example, we ask for the Euclidean norm: <pre class="syntax">
SELECT madlib.matrix_norm('"mat_A_sparse"', 'row="rowNum", col=col_num, val=entry', '2');
</pre> <pre class="result">
  matrix_norm
---------------
 24.9399278267
(1 row)
</pre></li>
</ol>
<p><a class="anchor" id="related"></a></p><dl class="section user"><dt>Related Topics</dt><dd></dd></dl>
<p>File <a class="el" href="array__ops_8sql__in.html" title="implementation of array operations in SQL ">array_ops.sql_in</a> documents the array operations <a class="el" href="group__grp__array.html">Array Operations</a></p>
<p>File <a class="el" href="matrix__ops_8sql__in.html" title="Implementation of matrix operations in SQL. ">matrix_ops.sql_in</a> for list of functions and usage. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 19 2022 12:19:23 for MADlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
