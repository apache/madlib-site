<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="keywords" content="madlib,postgres,greenplum,machine learning,data mining,deep learning,ensemble methods,data science,market basket analysis,affinity analysis,pca,lda,regression,elastic net,huber white,proportional hazards,k-means,latent dirichlet allocation,bayes,support vector machines,svm"/>
<title>MADlib: Logistic Regression</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<!-- hack in the navigation tree -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="madlib_extra.css" rel="stylesheet" type="text/css"/>
<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45382226-1', 'madlib.apache.org');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://madlib.apache.org"><img alt="Logo" src="madlib.png" height="50" style="padding-left:0.5em;" border="0"/ ></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   <span id="projectnumber">1.19.0</span>
   </div>
   <div id="projectbrief">User Documentation for Apache MADlib</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__grp__logreg.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Logistic Regression<div class="ingroups"><a class="el" href="group__grp__super.html">Supervised Learning</a> &raquo; <a class="el" href="group__grp__regml.html">Regression Models</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><b>Contents</b><ul>
<li class="level1">
<a href="#train">Training Function</a> </li>
<li class="level1">
<a href="#predict">Prediction Function</a> </li>
<li class="level1">
<a href="#examples">Examples</a> </li>
<li class="level1">
<a href="#background">Technical Background</a> </li>
<li class="level1">
<a href="#literature">Literature</a> </li>
<li class="level1">
<a href="#related">Related Topics</a> </li>
</ul>
</div><p>Binomial logistic regression models the relationship between a dichotomous dependent variable and one or more predictor variables. The dependent variable may be a Boolean value or a categorial variable that can be represented with a Boolean expression. The probabilities describing the possible outcomes of a single trial are modeled, as a function of the predictor variables, using a logistic function.</p>
<p><a class="anchor" id="train"></a></p><dl class="section user"><dt>Training Function</dt><dd>The logistic regression training function has the following format: <pre class="syntax">
logregr_train( source_table,
               out_table,
               dependent_varname,
               independent_varname,
               grouping_cols,
               max_iter,
               optimizer,
               tolerance,
               verbose
             )
</pre> <b>Arguments</b> <dl class="arglist">
<dt>source_table </dt>
<dd><p class="startdd">TEXT. Name of the table containing the training data.</p>
<p class="enddd"></p>
</dd>
<dt>out_table </dt>
<dd><p class="startdd">TEXT. Name of the generated table containing the output model.</p>
<p>The output table produced by the logistic regression training function contains the following columns:</p>
<table class="output">
<tr>
<th>&lt;...&gt; </th><td><p class="starttd">TEXT. Grouping columns, if provided in input. This could be multiple columns depending on the <code>grouping_cols</code> input. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>coef </th><td><p class="starttd">FLOAT8. Vector of the coefficients of the regression. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>log_likelihood </th><td><p class="starttd">FLOAT8. The log-likelihood \( l(\boldsymbol c) \). </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>std_err </th><td><p class="starttd">FLOAT8[]. Vector of the standard error of the coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>z_stats </th><td><p class="starttd">FLOAT8[]. Vector of the z-statistics of the coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>p_values </th><td><p class="starttd">FLOAT8[]. Vector of the p-values of the coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>odds_ratios </th><td><p class="starttd">FLOAT8[]. The odds ratio, \( \exp(c_i) \). </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>condition_no </th><td><p class="starttd">FLOAT8[]. The condition number of the \(X^{*}X\) matrix. A high condition number is usually an indication that there may be some numeric instability in the result yielding a less reliable model. A high condition number often results when there is a significant amount of colinearity in the underlying design matrix, in which case other regression techniques may be more appropriate. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_rows_processed </th><td><p class="starttd">INTEGER. The number of rows actually processed, which is equal to the total number of rows in the source table minus the number of skipped rows. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_missing_rows_skipped </th><td><p class="starttd">INTEGER. The number of rows skipped during the training. A row will be skipped if the independent_varname is NULL or contains NULL values. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_iterations </th><td><p class="starttd">INTEGER. The number of iterations actually completed. This would be different from the <code>nIterations</code> argument if a <code>tolerance</code> parameter is provided and the algorithm converges before all iterations are completed. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>variance_covariance </th><td>FLOAT[]. Variance/covariance matrix.  </td></tr>
</table>
<p>A summary table named &lt;out_table&gt;_summary is also created at the same time, which has the following columns: </p><table class="output">
<tr>
<th>method </th><td><p class="starttd">'logregr' for logistic regression. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>source_table </th><td><p class="starttd">The data source table name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>out_table </th><td><p class="starttd">The output table name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>dependent_varname </th><td><p class="starttd">The dependent variable name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>independent_varname </th><td><p class="starttd">The independent variable names. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>optimizer_params </th><td><p class="starttd">A string that contains all the optimizer parameters, and has the form of 'optimizer=..., max_iter=..., tolerance=...' </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_all_groups </th><td><p class="starttd">How many groups of data were fit by the logistic model. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_failed_groups </th><td><p class="starttd">How many groups failed in training. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_rows_processed </th><td><p class="starttd">The total number of rows used in the computation. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_missing_rows_skipped </th><td><p class="starttd">The total number of rows skipped. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>grouping_cols </th><td>Names of the grouping columns.  </td></tr>
</table>
<p class="enddd"></p>
</dd>
<dt>dependent_varname </dt>
<dd><p class="startdd">TEXT. Name of the dependent variable column (of type BOOLEAN) in the training data, or an expression evaluating to a BOOLEAN.</p>
<p class="enddd"></p>
</dd>
<dt>independent_varname </dt>
<dd><p class="startdd">TEXT. Expression list to evaluate for the independent variables. An intercept variable is not assumed so it is common to provide an explicit intercept term by including a single constant <code>1</code> term in the independent variable list.</p>
<p class="enddd"></p>
</dd>
<dt>grouping_cols (optional) </dt>
<dd><p class="startdd">TEXT, default: NULL. An expression list used to group the input dataset into discrete groups, running one regression per group. Similar to the SQL "GROUP BY" clause. When this value is NULL, no grouping is used and a single model is generated for the whole data set.</p>
<p class="enddd"></p>
</dd>
<dt>max_iter (optional) </dt>
<dd><p class="startdd">INTEGER, default: 20. The maximum number of iterations allowed.</p>
<p class="enddd"></p>
</dd>
<dt>optimizer (optional) </dt>
<dd><p class="startdd">TEXT, default: 'irls'. The name of the optimizer to use: </p><table class="output">
<tr>
<th>'newton' or 'irls' </th><td>Iteratively reweighted least squares  </td></tr>
<tr>
<th>'cg' </th><td>conjugate gradient  </td></tr>
<tr>
<th>'igd' </th><td>incremental gradient descent.  </td></tr>
</table>
<p class="enddd"></p>
</dd>
<dt>tolerance (optional) </dt>
<dd><p class="startdd">FLOAT8, default: 0.0001. The difference between log-likelihood values in successive iterations that indicate convergence. A zero disables the convergence criterion, so that execution stops after the maximum iterations have completed, as set in the 'max_iter' parameter above.</p>
<p class="enddd"></p>
</dd>
<dt>verbose (optional) </dt>
<dd>BOOLEAN, default: FALSE. Provides verbose output of the results of training. </dd>
</dl>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For p-values, we just return the computation result directly. Other statistical packages like 'R' produce the same result, but on printing the result to screen, another format function is used and any p-value that is smaller than the machine epsilon (the smallest positive floating-point number 'x' such that '1 + x != 1') will be printed on screen as "&lt; xxx" (xxx is the value of the machine epsilon). Although the result may look different, they are in fact the same.</dd></dl>
<p><a class="anchor" id="predict"></a></p><dl class="section user"><dt>Prediction Function</dt><dd>Two prediction functions are provided. One predicts the boolean value of the dependent variable, and the other predicts the probability of the value of the dependent variable being 'True'. Syntax is the same for both functions.</dd></dl>
<p>The function to predict the boolean value (True/False) of the dependent variable has the following syntax: </p><pre class="syntax">
logregr_predict(coefficients,
                ind_var
               )
</pre><p>The function to predict the probability of the dependent variable being 'True' has the following syntax: </p><pre class="syntax">
logregr_predict_prob(coefficients,
                     ind_var
                    )
</pre><p><b>Arguments</b> </p><dl class="arglist">
<dt>coefficients </dt>
<dd><p class="startdd">DOUBLE PRECISION[]. Model coefficients obtained from training <a class="el" href="logistic_8sql__in.html#a74210a7ef513dfcbdfdd9f3b37bfe428">logregr_train()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>ind_var </dt>
<dd>Independent variables expressed as a DOUBLE array. This should be the same length as the array obtained by evaluation of the 'independent_varname' argument in <a class="el" href="logistic_8sql__in.html#a74210a7ef513dfcbdfdd9f3b37bfe428">logregr_train()</a>. </dd>
</dl>
<p><a class="anchor" id="examples"></a></p><dl class="section user"><dt>Examples</dt><dd><ol type="1">
<li>Create the training data table. This data set is related to predicting a second heart attack given treatment and health factors. <pre class="example">
DROP TABLE IF EXISTS patients;
CREATE TABLE patients( id INTEGER NOT NULL,
                       second_attack INTEGER,
                       treatment INTEGER,
                       trait_anxiety INTEGER);
INSERT INTO patients VALUES
(1,  1, 1, 70),
(2,  1, 1, 80),
(3,  1, 1, 50),
(4,  1, 0, 60),
(5,  1, 0, 40),
(6,  1, 0, 65),
(7,  1, 0, 75),
(8,  1, 0, 80),
(9,  1, 0, 70),
(10, 1, 0, 60),
(11, 0, 1, 65),
(12, 0, 1, 50),
(13, 0, 1, 45),
(14, 0, 1, 35),
(15, 0, 1, 40),
(16, 0, 1, 50),
(17, 0, 0, 55),
(18, 0, 0, 45),
(19, 0, 0, 50),
(20, 0, 0, 60);
</pre></li>
<li>Train a regression model. <pre class="example">
DROP TABLE IF EXISTS patients_logregr, patients_logregr_summary;
SELECT madlib.logregr_train( 'patients',                             -- Source table
                             'patients_logregr',                     -- Output table
                             'second_attack',                        -- Dependent variable
                             'ARRAY[1, treatment, trait_anxiety]',   -- Feature vector
                             NULL,                                   -- Grouping
                             20,                                     -- Max iterations
                             'irls'                                  -- Optimizer to use
                           );
</pre> Note that in the example above we are dynamically creating the array of independent variables from column names. If you have large numbers of independent variables beyond the PostgreSQL limit of maximum columns per table, you would typically pre-build the arrays and store them in a single column.</li>
<li>View the regression results. <pre class="example">
-- Set extended display on for easier reading of output
\x on
SELECT * from patients_logregr;
</pre> Result: <pre class="result">
coef                     | {-6.36346994178192,-1.02410605239327,0.119044916668607}
log_likelihood           | -9.41018298388876
std_err                  | {3.21389766375099,1.17107844860319,0.0549790458269317}
z_stats                  | {-1.97998524145757,-0.874498248699539,2.16527796868916}
p_values                 | {0.0477051870698145,0.381846973530455,0.0303664045046183}
odds_ratios              | {0.00172337630923221,0.359117354054956,1.12642051220895}
condition_no             | 326.081922791575
num_rows_processed       | 20
num_missing_rows_skipped | 0
num_iterations           | 5
variance_covariance      | {{10.329138193064,-0.474304665195738,-0.171995901260057}, ...
</pre></li>
<li>Alternatively, unnest the arrays in the results for easier reading of output: <pre class="example">
\x off
SELECT unnest(array['intercept', 'treatment', 'trait_anxiety']) as attribute,
       unnest(coef) as coefficient,
       unnest(std_err) as standard_error,
       unnest(z_stats) as z_stat,
       unnest(p_values) as pvalue,
       unnest(odds_ratios) as odds_ratio
    FROM patients_logregr;
</pre> Result: <pre class="result">
   attribute   |    coefficient    |   standard_error   |       z_stat       |       pvalue       |     odds_ratio
---------------+-------------------+--------------------+--------------------+--------------------+---------------------
 intercept     | -6.36346994178192 |   3.21389766375099 |  -1.97998524145757 | 0.0477051870698145 | 0.00172337630923221
 treatment     | -1.02410605239327 |   1.17107844860319 | -0.874498248699539 |  0.381846973530455 |   0.359117354054956
 trait_anxiety | 0.119044916668607 | 0.0549790458269317 |   2.16527796868916 | 0.0303664045046183 |    1.12642051220895
(3 rows)
</pre></li>
<li>Predict the dependent variable using the logistic regression model. (This example uses the original data table to perform the prediction. Typically a different test dataset with the same features as the original training dataset would be used for prediction.) <pre class="example">
\x off
-- Display prediction value along with the original value
SELECT p.id, madlib.logregr_predict(coef, ARRAY[1, treatment, trait_anxiety]),
       p.second_attack::BOOLEAN
FROM patients p, patients_logregr m
ORDER BY p.id;
</pre> Result: <pre class="result">
  id | logregr_predict | second_attack
----+-----------------+---------------
  1 | t               | t
  2 | t               | t
  3 | f               | t
  4 | t               | t
  5 | f               | t
  6 | t               | t
  7 | t               | t
  8 | t               | t
  9 | t               | t
 10 | t               | t
 11 | t               | f
 12 | f               | f
 13 | f               | f
 14 | f               | f
 15 | f               | f
 16 | f               | f
 17 | t               | f
 18 | f               | f
 19 | f               | f
 20 | t               | f
(20 rows)
</pre></li>
<li>Predict the probability of the dependent variable being TRUE. <pre class="example">
\x off
-- Display prediction value along with the original value
SELECT p.id, madlib.logregr_predict_prob(coef, ARRAY[1, treatment, trait_anxiety]),
       p.second_attack::BOOLEAN
FROM patients p, patients_logregr m
ORDER BY p.id;
</pre> Result: <pre class="result">
 id | logregr_predict_prob | second_attack
----+----------------------+---------------
  1 |    0.720223028941527 | t
  2 |    0.894354902502048 | t
  3 |    0.192269541755171 | t
  4 |    0.685513072239347 | t
  5 |    0.167747881508857 | t
  6 |     0.79809810891514 | t
  7 |    0.928568075752503 | t
  8 |    0.959305763693571 | t
  9 |    0.877576117431452 | t
 10 |    0.685513072239347 | t
 11 |    0.586700895943317 | f
 12 |    0.192269541755171 | f
 13 |    0.116032010632994 | f
 14 |   0.0383829143134982 | f
 15 |   0.0674976224147597 | f
 16 |    0.192269541755171 | f
 17 |    0.545870774302621 | f
 18 |    0.267675422387132 | f
 19 |    0.398618639285111 | f
 20 |    0.685513072239347 | f
(20 rows)
</pre></li>
</ol>
</dd></dl>
<p><a class="anchor" id="notes"></a></p><dl class="section user"><dt>Notes</dt><dd>All table names can be optionally schema qualified (current_schemas() would be searched if a schema name is not provided) and all table and column names should follow case-sensitivity and quoting rules per the database. (For instance, 'mytable' and 'MyTable' both resolve to the same entity, i.e. 'mytable'. If mixed-case or multi-byte characters are desired for entity names then the string should be double-quoted; in this case the input would be '"MyTable"').</dd></dl>
<p><a class="anchor" id="background"></a></p><dl class="section user"><dt>Technical Background</dt><dd></dd></dl>
<p>(Binomial) logistic regression refers to a stochastic model in which the conditional mean of the dependent dichotomous variable (usually denoted \( Y \in \{ 0,1 \} \)) is the logistic function of an affine function of the vector of independent variables (usually denoted \( \boldsymbol x \)). That is, </p><p class="formulaDsp">
\[ E[Y \mid \boldsymbol x] = \sigma(\boldsymbol c^T \boldsymbol x) \]
</p>
<p> for some unknown vector of coefficients \( \boldsymbol c \) and where \( \sigma(x) = \frac{1}{1 + \exp(-x)} \) is the logistic function. Logistic regression finds the vector of coefficients \( \boldsymbol c \) that maximizes the likelihood of the observations.</p>
<p>Let</p><ul>
<li>\( \boldsymbol y \in \{ 0,1 \}^n \) denote the vector of observed dependent variables, with \( n \) rows, containing the observed values of the dependent variable,</li>
<li>\( X \in \mathbf R^{n \times k} \) denote the design matrix with \( k \) columns and \( n \) rows, containing all observed vectors of independent variables \( \boldsymbol x_i \) as rows.</li>
</ul>
<p>By definition, </p><p class="formulaDsp">
\[ P[Y = y_i | \boldsymbol x_i] = \sigma((-1)^{(1 - y_i)} \cdot \boldsymbol c^T \boldsymbol x_i) \,. \]
</p>
<p> Maximizing the likelihood \( \prod_{i=1}^n \Pr(Y = y_i \mid \boldsymbol x_i) \) is equivalent to maximizing the log-likelihood \( \sum_{i=1}^n \log \Pr(Y = y_i \mid \boldsymbol x_i) \), which simplifies to </p><p class="formulaDsp">
\[ l(\boldsymbol c) = -\sum_{i=1}^n \log(1 + \exp((-1)^{(1 - y_i)} \cdot \boldsymbol c^T \boldsymbol x_i)) \,. \]
</p>
<p> The Hessian of this objective is \( H = -X^T A X \) where \( A = \text{diag}(a_1, \dots, a_n) \) is the diagonal matrix with \( a_i = \sigma(\boldsymbol c^T \boldsymbol x) \cdot \sigma(-\boldsymbol c^T \boldsymbol x) \,. \) Since \( H \) is non-positive definite, \( l(\boldsymbol c) \) is convex. There are many techniques for solving convex optimization problems. Currently, logistic regression in MADlib can use one of three algorithms:</p><ul>
<li>Iteratively Reweighted Least Squares</li>
<li>A conjugate-gradient approach, also known as Fletcher-Reeves method in the literature, where we use the Hestenes-Stiefel rule for calculating the step size.</li>
<li>Incremental gradient descent, also known as incremental gradient methods or stochastic gradient descent in the literature.</li>
</ul>
<p>We estimate the standard error for coefficient \( i \) as </p><p class="formulaDsp">
\[ \mathit{se}(c_i) = \left( (X^T A X)^{-1} \right)_{ii} \,. \]
</p>
<p> The Wald z-statistic is </p><p class="formulaDsp">
\[ z_i = \frac{c_i}{\mathit{se}(c_i)} \,. \]
</p>
<p>The Wald \( p \)-value for coefficient \( i \) gives the probability (under the assumptions inherent in the Wald test) of seeing a value at least as extreme as the one observed, provided that the null hypothesis ( \( c_i = 0 \)) is true. Letting \( F \) denote the cumulative density function of a standard normal distribution, the Wald \( p \)-value for coefficient \( i \) is therefore </p><p class="formulaDsp">
\[ p_i = \Pr(|Z| \geq |z_i|) = 2 \cdot (1 - F( |z_i| )) \]
</p>
<p> where \( Z \) is a standard normally distributed random variable.</p>
<p>The odds ratio for coefficient \( i \) is estimated as \( \exp(c_i) \).</p>
<p>The condition number is computed as \( \kappa(X^T A X) \) during the iteration immediately <em>preceding</em> convergence (i.e., \( A \) is computed using the coefficients of the previous iteration). A large condition number (say, more than 1000) indicates the presence of significant multicollinearity.</p>
<p><a class="anchor" id="literature"></a></p><dl class="section user"><dt>Literature</dt><dd></dd></dl>
<p>A selection of references pertaining to logistic regression, with some good pointers to other literature.</p>
<p>[1] Cosma Shalizi: Statistics 36-350: Data Mining, Lecture Notes, 18 November 2009, <a href="http://www.stat.cmu.edu/~cshalizi/350/lectures/26/lecture-26.pdf">http://www.stat.cmu.edu/~cshalizi/350/lectures/26/lecture-26.pdf</a></p>
<p>[2] Thomas P. Minka: A comparison of numerical optimizers for logistic regression, 2003 (revised Mar 26, 2007), <a href="http://research.microsoft.com/en-us/um/people/minka/papers/logreg/minka-logreg.pdf">http://research.microsoft.com/en-us/um/people/minka/papers/logreg/minka-logreg.pdf</a></p>
<p>[3] Paul Komarek, Andrew W. Moore: Making Logistic Regression A Core Data Mining Tool With TR-IRLS, IEEE International Conference on Data Mining 2005, pp. 685-688, <a href="http://komarix.org/ac/papers/tr-irls.short.pdf">http://komarix.org/ac/papers/tr-irls.short.pdf</a></p>
<p>[4] D. P. Bertsekas: Incremental gradient, subgradient, and proximal methods for convex optimization: a survey, Technical report, Laboratory for Information and Decision Systems, 2010, <a href="http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf">http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf</a></p>
<p>[5] A. Nemirovski, A. Juditsky, G. Lan, and A. Shapiro: Robust stochastic approximation approach to stochastic programming, SIAM Journal on Optimization, 19(4), 2009, <a href="http://www2.isye.gatech.edu/~nemirovs/SIOPT_RSA_2009.pdf">http://www2.isye.gatech.edu/~nemirovs/SIOPT_RSA_2009.pdf</a></p>
<p><a class="anchor" id="related"></a></p><dl class="section user"><dt>Related Topics</dt><dd></dd></dl>
<p>File <a class="el" href="logistic_8sql__in.html" title="SQL functions for logistic regression. ">logistic.sql_in</a> documenting the training function</p>
<p><a class="el" href="logistic_8sql__in.html#a74210a7ef513dfcbdfdd9f3b37bfe428" title="Compute logistic-regression coefficients and diagnostic statistics. ">logregr_train()</a></p>
<p><a class="el" href="elastic__net_8sql__in.html#a735038a5090c112505c740a90a203e83" title="Interface for elastic net. ">elastic_net_train()</a></p>
<p><a class="el" href="group__grp__linreg.html">Linear Regression</a></p>
<p><a class="el" href="group__grp__multinom.html">Multinomial Regression</a></p>
<p><a class="el" href="group__grp__ordinal.html">Ordinal Regression</a></p>
<p><a class="el" href="group__grp__robust.html">Robust Variance</a></p>
<p><a class="el" href="group__grp__clustered__errors.html">Clustered Variance</a></p>
<p><a class="el" href="group__grp__validation.html">Cross Validation</a></p>
<p><a class="el" href="group__grp__marginal.html">Marginal Effects</a></p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 15 2021 20:27:20 for MADlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
